///////////////////////////////////////////////////////////
//  OperationalLimit.cs
//  Implementation of the Class OperationalLimit
//  Generated by Enterprise Architect
//  Created on:      15-Jun-2024 10:05:10 AM
//  Original author: kdd
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;



using TC57CIM.IEC61970.Base.OperationalLimits;
using TC57CIM.IEC61970.Base.Core;
using TC57CIM.IEC61970.InfIEC61970.InfOperationalLimits;
namespace TC57CIM.IEC61970.Base.OperationalLimits {
	/// <summary>
	/// A value and normal value associated with a specific kind of limit.
	/// The sub class value and normalValue attributes vary inversely to the associated
	/// OperationalLimitType.acceptableDuration (acceptableDuration for short).
	/// If a particular piece of equipment has multiple operational limits of the same
	/// kind (apparent power, current, etc.), the limit with the greatest
	/// acceptableDuration shall have the smallest limit value and the limit with the
	/// smallest acceptableDuration shall have the largest limit value.  Note: A large
	/// current can only be allowed to flow through a piece of equipment for a short
	/// duration without causing damage, but a lesser current can be allowed to flow
	/// for a longer duration.
	/// </summary>
	public class OperationalLimit : IdentifiedObject {

		/// <summary>
		/// The limit type associated with this limit.
		/// </summary>
		public TC57CIM.IEC61970.Base.OperationalLimits.OperationalLimitType OperationalLimitType;
		/// <summary>
		/// The limit dependency models which are used to calculate this limit.   If no
		/// limit dependencies are specified then the native limit value is used.
		/// </summary>
		public TC57CIM.IEC61970.InfIEC61970.InfOperationalLimits.LimitDependency LimitDependencyModel;

		public OperationalLimit(){

		}

		~OperationalLimit(){

		}

		public override void Dispose(){

		}

	}//end OperationalLimit

}//end namespace OperationalLimits